#!/usr/bin/env bash
# Copyright 2013 Telefonica Investigacion y Desarrollo, S.A.U
#
# This file is part of fiware-device-simulator (FI-WARE project).
#
# fiware-device-simulator is free software: you can redistribute it and/or
# modify it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# fiware-device-simulator is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero
# General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with fiware-device-simulator. If not, see http://www.gnu.org/licenses/.
#
# For those usages not covered by this license please contact with
# iot_support at tid dot es

# Bash lib to know the RPM version and revision from a GitHub repository
# Call method get_rpm_version_string to obtain them for rpmbuild
#

# ==========================
# RELEASE AND TAGGING POLICY
# ==========================
#
# 1) TAGS of the form:
#   X.Y.Z
# where X, Y & Z are numbers *only* increasing following this policy:
#   - X Major component functionalyty change, breaking compatibility, API changes... 
#     A change in X generates a branch and tag called release/X.Y.0 and X.Y.0 respectively 
#   - Y Major functionality changes not breaking functional compatibility.
#     A change in Y generates a branch and tag called release/X.Y.0 and X.Y.0 respectively 
#   - Z minor functional changes and bug fixes.
#     A change in Z ONLY generates new tag called X.Y.Z in branch release/X.Y.0 
#
# 2) GIT BRANCHES
# - 'develop'       -> to generate packages in Continuous Integration
# - 'release/X.Y.0' -> generated by developers after a Code Complete milestone
#
# 3) Packaging format
#
# The 'version' part of a package name is always X.Y.Z
# The 'release' part of a package name has the form N-<commit hash>
#
# 3.1 For releases
#   Look for the latest tag in the given release.
#   package format is foo-X.Y.Z+0-<commit hash>
#
#   The "distance" (in number of commits) from the latest tag 
#   to the latest commit should always be 0
#
# 3.2 For Continuous integration (develop Branch)
#   Look for the distance between the HEAD and the latest tag
#   in the lastest branch
#   Package format is foo-X.Y.Z-N-<commit hash>




if [[ $(ps hp  $$ | grep bash) ]]; then
  shopt -s extglob
elif [[ $(ps hp  $$ | grep zsh) ]]; then
  setopt kshglob
fi

get_branch()
{
    git name-rev --name-only HEAD
}

## Specific functions according the TID workflow
get_branch_type()
{
    local branch="$(get_branch)"
    case $branch in
        release/*) echo "release" ;;
        master)    echo "master" ;;
        develop)   echo "develop" ;;
        *)         echo "other"   ;;
    esac
}

get_version_string()
{
    local branch_name describe_tags version ancestor release latest_tag_in_release latest_tag_in_develop
    case $(get_branch_type) in
        stable)
           # If we are on stable branch get last tag as the version, but transform to x.x.x-x-SHA1
           describe_tags="$(git describe --tags --long  --match "[[:digit:]]*.[[:digit:]]*.[[:digit:]]*" 2>/dev/null)"
           version="${describe_tags%-*-*}"
           echo "${version%.*}-${version#*.*.*.}-$(git log --pretty=format:'%h' -1)"
        ;;
        develop)
          # hace un checkout a la ultima rama release a partir del tag
          latest_tag_in_develop=$(git describe --tags --long 2>/dev/null)
          git checkout "release/${latest_tag_in_develop%-*-*}" &> /dev/null
          # se recoge el ultimo tag de la rama release/x.y.z
          latest_tag_in_release=$(git describe --tags --long 2>/dev/null)
          # La version es el tag de esa rama
          version=${latest_tag_in_release%-*-*}
          git checkout "develop"  &> /dev/null
          # como release aparece numero de commits desde que se abrio la rama release
          release=${latest_tag_in_develop#*-}
          echo "${version}-${release}"
        ;;
        master)
          # hace un checkout a la ultima rama release a a partir del tag
          latest_tag_in_master=$(git describe --tags --long 2>/dev/null)
          git checkout "release/${latest_tag_in_master%-*-*}" &> /dev/null
          # se recoge el ultimo tag de la rama release/x.y.z
          latest_tag_in_release=$(git describe --tags --long 2>/dev/null)
          # La version es el tag de esa rama
          version=${latest_tag_in_release%-*-*}
          git checkout "master"  &> /dev/null
          # como release aparece numero de commits desde que se abrio la rama release
          release=${latest_tag_in_master#*-}
          echo "${version}-${release}"
        ;;
        release)
          # se coge el ultimo tag y eso es la version
          describe_tags=$(git describe --tags --long 2>/dev/null)
          version=${describe_tags%-*-*}
          git checkout "${version}" &> /dev/null
          describe_tags=$(git describe --tags --long 2>/dev/null)
          # la parte releaase es la release del tag que ser√° +0-<hash>
          release=${describe_tags#*.*.*-}
          echo "${version}-${release}"
        ;;
        *)
            full_version="$(git describe --tags --long --match "[[:digit:]]*.[[:digit:]]*.[[:digit:]]*")"
            version="${full_version%%-*}_devel"
            release="${full_version#*-}"
            release="${release/-/.}"
            echo "${version}-${release}"
           
    esac
}

get_rpm_version_string() {
    local version_string ver rel
    version_string="$(get_version_string)"
    ver="${version_string%-*}"
    rel="${version_string:$((${#ver}+1))}"
    echo "${ver//[[:space:]-\/#]}" "${rel//[-]/.}"
}

